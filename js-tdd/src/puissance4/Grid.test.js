/**


# init = grille vide

undefined => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
]


# On peut ajouter des pions X

X, 4 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', 'X', '.', '.', '.'],
]

X, 2 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', 'X', '.', '.', '.', '.', '.'],
]

# On peut ajouter des pions O

O, 2 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', 'O', '.', '.', '.', '.', '.'],
]

O, 6 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', 'O', '.'],
]

# Coups

X, 1 ; O, 2 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ 'X', 'O', '.', '.', '.', '.', '.'],
]

O, 4 ; X, 5 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', 'O', 'X', '.', '.'],
]

X, 1 ; O, 1 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ 'O', '.', '.', '.', '.', '.', '.'],
    [ 'X', '.', '.', '.', '.', '.', '.'],
]

O, 4 ; X, 4 => [
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', '.', '.', '.', '.'],
    [ '.', '.', '.', 'X', '.', '.', '.'],
    [ '.', '.', '.', 'O', '.', '.', '.'],
]


X, 4, X, 4: X4 ... x 7 => throw
X, -1 => throw
X, 9 => throw
 
 

passer la grille dans l'etat initial et s'arrurer qu'elle est vide


quand on joue au meme endroit ne pas écraser la place de l'autre joueurs
4 aligné et c'est gagné ( horizontal, vertical, diagonal..peux importe ou )

 * 
 */

describe('puissance', () => {

    const Grid = require('./Grid')

    it('should return an empty array when no play', () => {
        const grid = new Grid();
        expect(grid.toArray()).toEqual([
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
        ]);
    });

    it('should return array with one X', () => {
        const grid = new Grid();
        grid.play('X', 4);
        expect(grid.toArray()).toEqual([
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', 'X', '.', '.', '.'],
        ]);
    });

    it('should return array with one X at col 2', () => {
        const grid = new Grid();
        grid.play('X', 2);
        expect(grid.toArray()).toEqual([
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', 'X', '.', '.', '.', '.', '.'],
        ]);
    });

    it('should return array with one O at col 2', () => {
        const grid = new Grid();
        grid.play('O', 2);
        expect(grid.toArray()).toEqual([
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', 'O', '.', '.', '.', '.', '.'],
        ]);
    });


    it('should return array with one O at col 2 and with X at col 1', () => {
        const grid = new Grid();
        grid.play('X', 1);
        grid.play('O', 2);
        expect(grid.toArray()).toEqual([
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ 'X', 'O', '.', '.', '.', '.', '.'],
        ]);
    });

    it('should return array with one O at col 1 and with X at col 1 (pile)', () => {
        const grid = new Grid();
        grid.play('X', 1);
        grid.play('O', 1);
        expect(grid.toArray()).toEqual([
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ 'O', '.', '.', '.', '.', '.', '.'],
            [ 'X', '.', '.', '.', '.', '.', '.'],
        ]);
    });

    it('should add player token on 2 colomn 4 times', () => {
        const grid = new Grid();
        grid.play('X', 1);
        grid.play('O', 1);
        grid.play('X', 1);
        grid.play('O', 1);
        grid.play('X', 3);
        grid.play('O', 3);
        grid.play('X', 3);
        grid.play('O', 3);
        grid.play('X', 3);

        expect(grid.toArray()).toEqual([
            [ '.', '.', '.', '.', '.', '.', '.'],
            [ '.', '.', 'X', '.', '.', '.', '.'],
            [ 'O', '.', 'O', '.', '.', '.', '.'],
            [ 'X', '.', 'X', '.', '.', '.', '.'],
            [ 'O', '.', 'O', '.', '.', '.', '.'],
            [ 'X', '.', 'X', '.', '.', '.', '.'],
        ]);
    });


});

